#include "ScannerS/Models/TRSMBroken.hpp"
#include "ScannerS/Utilities.hpp"
#include "catch.hpp"
#include "prettyprint.hpp"

TEST_CASE("TRSMBroken Generate", "[unit][TRSM]") {
  using ScannerS::Models::TRSMBroken;
  TRSMBroken::AngleInput in{125.09, 200, 250, -0.3, 1.4, -0.7, 246, 10, 500};

  TRSMBroken::ParameterPoint p{in};

  CHECK(p.mHi[0] == in.mHa);
  CHECK(p.mHi[1] == in.mHb);
  CHECK(p.mHi[2] == in.mHc);
  CHECK(p.theta[0] == Approx(in.t1));
  CHECK(p.theta[1] == Approx(in.t2));
  CHECK(p.theta[2] == Approx(in.t3));
  CHECK(p.v == Approx(in.v));
  CHECK(p.vs == Approx(in.vs));
  CHECK(p.vx == Approx(in.vx));
  const std::array<std::array<double, 3>, 3> comp{
      {{0.162376, 0.0502287, -0.98545},
       {0.380463, 0.918291, 0.109496},
       {0.910429, -0.392707, 0.129998}}};
  for (size_t i = 0; i != 3; ++i) {
    for (size_t j = 0; j != 3; ++j) {
      CHECK(p.R(i, j) == Approx(comp[i][j]));
    }
  }
  const std::array<double, 6> Lcomp{0.479276, 217.042,   0.0334625,
                                    -3.35085, 0.0533308, 0.0113492};
  for (size_t i = 0; i != 6; ++i) {
    CHECK(p.L[i] == Approx(Lcomp[i]));
  }
  CHECK(p.muHsq == Approx(-35502.7));
  CHECK(p.muSsq == Approx(78267.1));
  CHECK(p.muXsq == Approx(-9979.88));
}

TEST_CASE("TRSM BFB", "[TRSM][unit]") {
  using ScannerS::Models::TRSM;

  const std::vector<std::array<double, 6>> Lstable{
      {5.78508, 4.52175, 6.34968, 7.18361, -9.94164, 0.321772},
      {8.42645, 8.99904, 6.43772, 8.35383, 0.619906, -7.61962},
      {3.04911, 3.02746, 6.95154, 6.4091, 0.909218, 1.38492},
      {7.72795, 8.76746, 4.46669, -4.74344, 5.35017, -2.29403},
      {5.83452, 7.31464, 6.43946, 8.94932, -4.49973, 4.73986},
      {0.536789, 1.84264, 6.63252, 7.16779, 5.2271, -5.30998},
      {6.31437, 9.15577, 1.20857, 8.5299, 1.04347, 3.4448},
      {6.07513, 2.02022, 1.04774, 2.56934, 2.83704, 2.56968},
      {0.930177, 0.0369927, 7.21005, 6.52232, 9.86549, 5.66357},
      {9.43537, 8.31176, 5.46162, 9.98654, 4.09034, 6.28604},
      {0.52916, 9.95882, 9.89745, 5.19132, -0.411556, 5.8704},
      {8.66378, 4.13196, 7.13548, 9.7038, -3.07572, 5.41097},
      {8.06374, 9.29745, 7.8676, 6.8791, -4.21765, -7.76349},
      {3.92423, 8.21979, 1.05397, 4.37586, 3.21313, 3.68099},
      {1.05951, 0.165592, 2.35881, 8.19547, 2.0706, -1.10424},
      {2.73141, 8.28173, 8.21034, 7.677, 4.75807, 1.62357}};

  const std::vector<std::array<double, 6>> Lunstable{
      {4.41189, 3.1854, 0.0036583, -0.070859, -8.96883, 0.332894},
      {6.29604, 2.01125, 9.79475, -7.77084, 8.90993, -5.49048},
      {6.41039, 0.481301, 7.0256, 0.736782, 7.31305, -4.307},
      {6.62631, 8.5528, -5.55314, -8.40139, -4.59971, -6.64805},
      {-5.65387, 1.9124, -5.59011, 0.0737753, -8.37008, -3.41065},
      {0.0645041, -9.32878, 8.64263, -3.43398, 9.9225, 6.86765},
      {3.89383, -5.57513, -7.13041, 8.47879, 8.30678, -1.78718},
      {-9.67906, -5.40193, -2.50996, -2.8069, -3.91079, -3.20877},
      {-7.30416, 7.57541, 3.43439, 4.93908, -2.88317, 4.24275},
      {-9.59487, -4.36389, -0.720425, -2.30091, 0.045366, -5.72776},
      {-2.96412, 8.31329, -0.573091, 9.48863, -3.88801, -3.58665},
      {9.6664, 2.2383, 0.728269, 3.59907, 8.42073, -7.51735},
      {1.68594, 2.65932, 0.95476, 7.09808, -6.01988, 8.42063},
      {0.931442, 4.78277, 6.70548, -7.14312, -4.10687, -9.24568}};

  for (const auto &x : Lstable) {
    CHECK(TRSM::BFB(x));
    if (!TRSM::BFB(x))
      WARN(x);
  }
  for (const auto &x : Lunstable) {
    CHECK_FALSE(TRSM::BFB(x));
    if (TRSM::BFB(x))
      WARN(x);
  }
}

TEST_CASE("TRSM Unitarity", "[TRSM][unit]") {
  using ScannerS::Models::TRSM;

  const std::vector<std::array<double, 6>> lamtest{
      {7.02065, 9.01041, -10.3686, 3.90483, 2.05623, -10.7313},
      {6.85049, 8.83875, -3.63507, 1.25542, -5.85783, 5.12179},
      {11.3133, -9.00549, -0.850645, -9.67382, -12.5355, -2.60357},
      {10.0941, 0.943134, -6.69643, -12.5422, -0.62798, -0.626495},
      {5.6532, 6.74957, -7.34736, -7.65539, -2.96202, 8.33769},
      {7.51746, -4.29501, 9.22318, -3.77058, -11.1987, -0.10151},
      {-10.774, -1.33446, 9.93953, -9.5361, 7.23287, 4.33274},
      {6.16707, 6.56501, -10.3383, -3.06175, -4.2464, 6.93214},
      {6.56416, -6.06565, -11.5556, 2.35888, -0.345545, 6.50254},
      {-6.69014, 2.57832, -7.99191, 11.6153, 9.97083, 11.9404},
      {-6.50381, 10.9212, -4.48019, -10.7052, -9.80446, -9.47485},
      {-3.07362, 9.75016, -9.57168, -3.4942, -10.2969, -11.3709},
      {-4.33004, 7.0597, -3.83482, 5.45321, -6.22476, -3.22385},
      {4.12342, -3.22032, 6.1994, 11.7399, 6.88014, 2.43225},
      {4.6938, -10.2725, -10.8245, -7.67131, -0.584211, 10.0502},
      {0.376785, 9.65177, 9.50706, 10.9241, 12.0701, 6.45817},
      {2.47425, -4.8263, -3.14053, 11.7121, -0.321701, 12.1642},
      {2.3758, 12.2113, 1.48285, 1.88332, 6.70559, 6.08979},
      {-12.4476, 4.80784, -5.80497, 9.51234, -5.59378, 0.535036},
      {-9.81052, 8.62723, -7.03375, 2.34633, -2.94273, -3.83244},
      {-8.71726, 9.39627, -6.61644, -10.9158, -5.12282, -8.02823},
      {7.97812, 10.5398, 0.528101, -12.377, -0.27765, 7.61367},
      {6.30905, 2.07443, -7.40007, 4.60746, -7.47739, -11.0994},
      {-3.61928, -11.8156, 8.22483, 1.26239, 10.4863, -0.490371},
      {5.80083, -11.555, -6.65489, 1.72212, -6.5253, -8.28373},
      {-3.28106, 6.50581, 6.21323, 1.82486, 3.2328, 6.65866},
      {2.997, -5.84797, 6.05202, 11.6386, -0.152307, -4.46476},
      {7.0081, 4.72916, 4.31946, -6.70476, -0.860763, -2.39114},
      {-3.12063, 10.9249, 10.6888, 0.730713, 3.73739, 11.3739},
      {-0.404285, 7.19154, 10.7301, 4.06994, -9.42842, -2.98284}};

  const std::vector<double> maxEVtest{
      43.0817, 41.8159, 70.9308, 63.1754, 37.6738, 50.7572, 66.6876, 37.8605,
      39.482,  46.15,   44.1172, 35.7703, 28.7092, 31.9651, 37.0701, 39.1377,
      21.4429, 37.2081, 76.2212, 59.1476, 54.6643, 54.6295, 39.6063, 35.5891,
      35.7516, 22.7276, 21.6374, 43.5889, 38.2875, 35.0481};

  REQUIRE(lamtest.size() == maxEVtest.size());

  for (size_t i = 0; i != lamtest.size(); ++i) {
    CHECK(TRSM::MaxUnitarityEV(lamtest[i]) == Approx(maxEVtest[i]));
  }
}

TEST_CASE("TRSM Triple", "[unit][TRSM]") {
  const std::array<double, 6> Lt{7.02065, 9.01041, -10.3686,
                                 3.90483, 2.05623, -10.7313};

  Eigen::Matrix3d Rt;
  Rt << 0.162376, 0.0502287, -0.98545, 0.380463, 0.918291, 0.109496, 0.910429,
      -0.392707, 0.129998;

  const double v = 246;
  const double vs = 100;
  const double vx = 432;

  auto coups3H = ScannerS::Models::TRSM::TripleHCoups(Lt, Rt, v, vs, vx);
  CHECK(coups3H.at("c_H1H1H3") == Approx(-1369.95 * 2));
  CHECK(coups3H.at("c_H1H2H2") == Approx(2432.41 * 2));
  CHECK(coups3H.at("c_H1H2H3") == Approx(-1051.04));
  CHECK(coups3H.at("c_H1H3H3") == Approx(828.004 * 2));
  CHECK(coups3H.at("c_H1H1H2") == Approx(-1587.84 * 2));
  CHECK(coups3H.at("c_H1H1H1") == Approx(4302.44 * 6));
  CHECK(coups3H.at("c_H2H2H2") == Approx(755.268 * 6));
  CHECK(coups3H.at("c_H2H2H3") == Approx(81.7761 * 2));
  CHECK(coups3H.at("c_H2H3H3") == Approx(2064.54 * 2));
  CHECK(coups3H.at("c_H3H3H3") == Approx(1251.63 * 6));
}

TEST_CASE("TRSMBroken Triple", "[unit][TRSM") {
  using ScannerS::Models::TRSM;
  using ScannerS::Models::TRSMBroken;
  TRSMBroken::AngleInput in{125.09, 200, 250, 0.3, -1.4, 0.7, 246, 10, 500};
  TRSMBroken::ParameterPoint p{in};

  p.data.Merge(TRSM::TripleHCoups(p.L, p.R, p.v, p.vs, p.vx));

  auto cijk = [&p](size_t a, size_t b, size_t c) -> double {
    std::array<double, 3> vevs{p.v, p.vs, p.vx};
    double x = 0;
    for (size_t j = 0; j != 3; ++j) {
      x += p.R(a, j) * p.R(b, j) * p.R(c, j) / vevs[j];
    }
    return x *
           (p.mHi[a] * p.mHi[a] + p.mHi[b] * p.mHi[b] + p.mHi[c] * p.mHi[c]);
  };

  CHECK(p.data["c_H1H1H1"] == Approx(cijk(0, 0, 0)));
  CHECK(p.data["c_H2H2H2"] == Approx(cijk(1, 1, 1)));
  CHECK(p.data["c_H3H3H3"] == Approx(cijk(2, 2, 2)));

  CHECK(p.data["c_H1H2H2"] == Approx(cijk(0, 1, 1)));
  CHECK(p.data["c_H1H1H2"] == Approx(cijk(1, 0, 0)));
  CHECK(p.data["c_H1H3H3"] == Approx(cijk(0, 2, 2)));
  CHECK(p.data["c_H1H1H3"] == Approx(cijk(2, 0, 0)));
  CHECK(p.data["c_H2H3H3"] == Approx(cijk(1, 2, 2)));
  CHECK(p.data["c_H2H2H3"] == Approx(cijk(2, 1, 1)));

  CHECK(p.data["c_H1H2H3"] == Approx(cijk(0, 1, 2)));
}
